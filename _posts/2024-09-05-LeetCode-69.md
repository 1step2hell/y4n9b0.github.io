---
layout: post
title: x 的平方根 
date: 2024-09-05 14:30:00 +0800
categories: program
tags: math
published: true
---

* content
{:toc}

## sqrt(x)

[LeetCode 69](https://leetcode.com/problems/sqrtx/description/){:target="_blank"}

Given a non-negative integer x, return the square root of x rounded down to the nearest integer. 
The returned integer should be non-negative as well.

You must not use any built-in exponent function or operator.

* For example, do not use `pow(x, 0.5)` in c++ or `x ** 0.5` in python.

**Example 1:**

```
Input: x = 4
Output: 2
Explanation: The square root of 4 is 2, so we return 2.
```

**Example 2:**

```
Input: x = 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.
```

**Constraints:**

* 0 <= x <= $$2^{31} - 1$$

## 二分查找

```c
int mySqrt(int x) {
    if (x == 0) return 0;
    int l = 1, r = x;

    while (l <= r) {
        int m = l + (r - l) / 2;
        if (m <= x / m) {
            l = m + 1;
        } else {
            r = m - 1;
        }
    }

    return r;
}
```

## 牛顿迭代

```c
int mySqrt(int x) {
    long r = (x + 1L) / 2;
    while (r * r > x) r = (r + x / r) / 2;
    return r;
}
```

## 0x1fbd1dfb

```c
int mySqrt(int x) {
    long i;
    float y;
    const float half = 0.5F;

    y = x;
    i = * ( long * ) &y;                // evil floating point bit level hacking
    i = 0x1fbd1dfb + ( i >> 1 );        // what the fuck?
    y = * ( float * ) &i;
    y = half * ( y + x / y );           // 1st iteration
    y = half * ( y + x / y );           // 2nd iteration

    int r = ( int ) y;
    if ( r * r > x ) r--;
    return r;
}
```

如上 C 代码在 LeetCode 运行会报错：

```txt
Line 7: Char 9: runtime error: load of address 0x7feda5c00030 with insufficient space for an object of type 'float' [solution.c]
0x7feda5c00030: note: pointer points here
 00 00 00 00  00 00 80 40 00 00 00 00  00 00 00 00 00 00 00 00  00 04 00 00 00 00 00 00  00 00 00 00
              ^
```

该问题是由于 C 语言中类型强制转换的内存对齐问题以及内存访问的非法操作引起的。<br>
第 7 行将 float 类型的指针（&y）强制转换为 long * 类型的指针，并尝试通过该指针获取 float 的 long representation。
这种类型强转的行为虽然在一些编译器或平台上可以运行，但并不是标准行为。由于 float 和 long 的内存布局可能不同，它们的对齐要求也不一样，这可能会导致未对齐的内存访问，从而引发运行时错误。

解决方案：使用联合体（union）来安全地处理 float 和 long 之间的 representation 转换，避免出现内存访问的问题。<br>
联合体的所有成员在内存中具有相同的首地址，共占同一段内存空间，这些成员可以相互覆盖，在不同的时间保存不同的数据类型和不同长度的成员的值。
编译程序会自动给变量分配存储空间，其长度为联合体的数据成员中所占内存空间最大的成员的长度。

```c
int mySqrt(int x) {
    union {
        float f;
        long l;
    } u;

    const float half = 0.5F;
    u.f = (float) x;
    u.l = 0x1fbd1dfb + (u.l >> 1);
    u.f = half * (u.f + x / u.f);       // 1st iteration
    u.f = half * (u.f + x / u.f);       // 2nd iteration

    int r = (int) u.f;
    if (r * r > x) r--;
    return r;
}
```

float 在内存中使用 32 位表示，而 long 视平台而定可能为 32 位，也可能为 64 位。
当 long 为 64 位时会导致上面联合体进行 float/long representation 转换符号位不正确，最终结果为相反的负数。
为了消除不同平台位数差异的影响，将联合体的 long 类型修改为 32 位整数 int32_t：

```c
int mySqrt(int x) {
    union {
        float f;
        int32_t i;
    } u;

    const float half = 0.5F;
    u.f = (float) x;
    u.i = 0x1fbd1dfb + (u.i >> 1);
    u.f = half * (u.f + x / u.f);       // 1st iteration
    u.f = half * (u.f + x / u.f);       // 2nd iteration

    int r = (int) u.f;
    if (r * r > x) r--;
    return r;
}
```

需要注意的是，使用 magic number + 牛顿迭代求出的结果更接近真正的平方根，与题目向下取整的要求有一点差异，所以最后还需要多一步判断是否减 1。